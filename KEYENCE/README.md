# KEYENCEの上位リンクコマンドを使ってPLCのメモリをロギング

## 環境
Python3.9  

## 実行例
```
memlogKV(0.1, 100, 'log')
```
## ファンクション
### memlogKV(interval, recnum, logpath)
定周期でlogwriteを実行します

#### interval : 収集周期
収集する周期を入力します 単位は秒  
例：0.1

#### recnum : 収集個数
設定した個数を収集するとプログラムを終了してファイルを閉じます

#### logpath : 収集ファイル出力ディレクトリ
ロギングするファイルの出力先です
ここで指定したディレクトリの下にファイル名は"logYYYYMMDD_HHSS.csv"で出力します

### logwrite(filename)
デバイスの値を読み出してcsvファイルに出力します

#### filename
出力先のファイル名

## 収集するデバイスの設定方法
### まずPLCのD0にビットデータとD1-19にワードデータがセットされてると想定します

| D0 | 1 - 19 |  
| --- | --- |  
| BitData | WORD |


### 読み出すデバイスはプログラムの先頭で指定します
```
# PLCのIPアドレス
host = '192.168.0.31'

# モニタ登録
# False: 連続アドレスで読み出す場合
# True: モニタ登録して読み出す場合
monitor = False

# 連続アドレスで読み出すデバイスアドレス
deviceAddress = 'D0.H'
readSize = 20
# モニタ登録して読み出すデバイスアドレス
monitorAddresses = 'DM0.H DM1.S DM2.L DM4.U DM5.D'
```

### 次に書き込むデータを順番に作っていきます  
まず読み出したデータはスペースで区切られているのでリストに変換します
```
datastr = data.decode().replace('\r\n', '')
datas = datastr.split(" ")
```
次から書込みデータを作成します  
最初の列には読み出した日付時刻 (ここはこのまま使います)
```
now = datetime.now()
f.write(now.strftime('%Y/%m/%d %H:%M:%S.') + "%03d" % (now.microsecond // 1000) + ',')
```
次は1つ目の文字列を16ビットに変換して出力します
```
dataB = bin(int(datas[0],16))[2:].zfill(16)
f.write(','.join(list(dataB)) + ',')
```

残りはそのままカンマ(,)でつないで出力します
```
f.write(','.join(datas[1:]) + '\n')
```

### 出力データ例
```
2022/05/22 14:19:03.987,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0001,0002,0003,0004,0001,0002,0003,0004,0009,4E20,0000,000C,000D,000E,000F,0010,0011,0012,0013
2022/05/22 14:19:04.089,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0001,0002,0003,0004,0001,0002,0003,0004,0009,4E20,0000,000C,000D,000E,000F,0010,0011,0012,0013
2022/05/22 14:19:04.190,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0001,0002,0003,0004,0001,0002,0003,0004,0009,4E20,0000,000C,000D,000E,000F,0010,0011,0012,0013
2022/05/22 14:19:04.287,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0001,0002,0003,0004,0001,0002,0003,0004,0009,4E20,0000,000C,000D,000E,000F,0010,0011,0012,0013
```

# Qiita記事
https://qiita.com/OkitaSystemDesign/items/ee25befed0b98d1d3588
